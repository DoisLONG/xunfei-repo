<!doctype html>
<html lang="zh">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>è¯­éŸ³æµå¼å¯¹è¯ï¼šå‰ç«¯æ¨¡æ¿ï¼ˆç¨³å®šç‰ˆï¼‰</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;margin:16px;color:#0f172a}
    .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    button{padding:8px 12px;border-radius:10px;border:1px solid #d4d4d8;background:#fff;cursor:pointer}
    button.primary{background:#0ea5e9;color:#fff;border-color:#0ea5e9}
    button.danger{background:#ef4444;color:#fff;border-color:#ef4444}
    .pill{padding:4px 10px;border-radius:999px;background:#f1f5f9;font-size:12px}
    .log{background:#0b1020;color:#d1e6ff;padding:10px;border-radius:8px;height:220px;overflow:auto;font-family:ui-monospace,Menlo,Consolas,monospace;font-size:12px}
    .box{border:1px solid #e5e7eb;border-radius:12px;padding:12px;margin-top:12px}
    textarea{width:100%;min-height:120px;border:1px solid #e5e7eb;border-radius:8px;padding:8px}
    audio{width:100%}.ok{color:#059669}.warn{color:#b45309}
  </style>
</head>
<body>
  <h2>è¯­éŸ³æµå¼å¯¹è¯ï¼šå‰ç«¯æ¨¡æ¿ï¼ˆç¨³å®šç‰ˆï¼‰</h2>

  <div class="row">
    <div>ç¼–ç ç±»å‹ï¼š</div>
    <select id="selMime">
      <option>audio/webm;codecs=opus</option>
      <option>audio/ogg;codecs=opus</option>
      <option>audio/webm</option>
    </select>
    <div>åˆ†ç‰‡æ—¶é•¿ï¼š</div>
    <input id="chunkMs" type="number" value="320" style="width:72px"/> ms
    <span id="wsState" class="pill">WS å·²å…³é—­</span>
    <span id="audioState" class="pill warn">æœªè§£é”</span>
    <label class="pill"><input id="cbAutoLog" type="checkbox" checked/> è‡ªåŠ¨æ»šåŠ¨æ—¥å¿—</label>
  </div>

  <div class="row" style="margin-top:8px;">
    <button id="btnInit" class="primary">åˆå§‹åŒ–éŸ³é¢‘ï¼ˆè§£é”è‡ªåŠ¨æ’­æ”¾ï¼‰</button>
    <button id="btnWS">è¿æ¥åç«¯</button>
    <button id="btnStart" class="primary">å¼€å§‹è¯´è¯</button>
    <button id="btnStop" class="danger">åœæ­¢</button>
    <button id="btnMockLLM">æ¨¡æ‹Ÿå›ç­”ï¼ˆè°ƒç”¨ TTSï¼‰</button>
  </div>

  <div class="box">
    <div><b>è½¬å†™ï¼ˆå®æ—¶ï¼‰</b></div>
    <textarea id="finalText" placeholder="æœ€ç»ˆè¯†åˆ«æ–‡æœ¬ä¼šç´¯è®¡åœ¨è¿™é‡Œ..."></textarea>
  </div>

  <div class="box">
    <div><b>TTS æ’­æ”¾é˜Ÿåˆ—</b></div>
    <audio id="player" controls class="muted"></audio>
    <div id="queueState" class="pill" style="margin-top:6px">é˜Ÿåˆ—ä¸ºç©º</div>
  </div>

  <div class="box">
    <div style="margin-bottom:6px;"><b>è°ƒè¯•æ—¥å¿—</b></div>
    <div id="log" class="log"></div>
  </div>

<script>
(() => {
  const WS_URL = (location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/ws/voice';

  const elLog = document.getElementById('log');
  const elFinal = document.getElementById('finalText');
  const elWS = document.getElementById('wsState');
  const elAudio = document.getElementById('audioState');
  const elSelMime = document.getElementById('selMime');
  const elChunk = document.getElementById('chunkMs');
  const elQueue = document.getElementById('queueState');
  const player = document.getElementById('player');
  const cbAutoLog = document.getElementById('cbAutoLog');

  const btnInit = document.getElementById('btnInit');
  const btnWS = document.getElementById('btnWS');
  const btnStart = document.getElementById('btnStart');
  const btnStop = document.getElementById('btnStop');
  const btnMock = document.getElementById('btnMockLLM');

  let ws=null, stream=null, rec=null, audioUnlocked=false;

  function log(...args){
    const s = args.map(a => (typeof a==='string'?a:JSON.stringify(a))).join(' ');
    elLog.textContent += `[${new Date().toTimeString().slice(0,8)}] ` + s + '\n';
    if(cbAutoLog.checked) elLog.scrollTop = elLog.scrollHeight;
  }

  class AudioQueue{
    constructor(player){
      this.player=player; this.queue=[]; this.playing=false;
      player.addEventListener('ended',()=>this._next());
      player.addEventListener('error',()=>this._next());
    }
    push(url){
      this.queue.push(url); this._render();
      if(!this.playing) this._next();
    }
    _next(){
      const url = this.queue.shift(); this._render();
      if(!url){ this.playing=false; return; }
      this.playing=true; this.player.src=url;
      this.player.play().then(()=>{
        elAudio.textContent='å·²è§£é”'; elAudio.classList.add('ok'); elAudio.classList.remove('warn');
      }).catch(()=>{});
    }
    _render(){ elQueue.textContent = this.queue.length ? `å¾…æ’­æ¸…å•ï¼ˆ${this.queue.length}ï¼‰` : 'é˜Ÿåˆ—ä¸ºç©º'; }
  }
  const q = new AudioQueue(player);

  async function unlock(){
    try{
      const ctx = new (window.AudioContext||window.webkitAudioContext)(); await ctx.resume();
      const osc = ctx.createOscillator(); osc.connect(ctx.destination); osc.start(); osc.stop(ctx.currentTime+0.01);
      audioUnlocked=true; player.classList.remove('muted');
      elAudio.textContent='å·²è§£é”'; elAudio.classList.add('ok'); elAudio.classList.remove('warn');
      log('Audio unlocked');
    }catch(e){ log('Audio unlock failed', e?.message||e); }
  }

  function connectWS(){
    if(ws && ws.readyState===WebSocket.OPEN) return;
    ws = new WebSocket(WS_URL); ws.binaryType='arraybuffer';
    ws.onopen = ()=>{
      elWS.textContent='WS å·²è¿æ¥';
      const mime = elSelMime.value;
      ws.send(JSON.stringify({type:'start', mime}));
      log('WS open -> start', mime);
    };
    ws.onclose = ()=>{ elWS.textContent='WS å·²å…³é—­'; log('WS close'); };
    ws.onerror = e => log('WS error', e?.message||'');
    ws.onmessage = ev=>{
      try{
        const msg = JSON.parse(ev.data);
        if(msg.type==='partial'){ /* å¯åŠ å±€éƒ¨æ˜¾ç¤º */ }
        else if(msg.type==='final'){ elFinal.value += msg.text || ''; }
        else if(msg.type==='llm'){ log('LLM', msg.text); }
        else if(msg.type==='tts' && msg.url){
          q.push(msg.url); log('âœ… å·²å…¥é˜ŸéŸ³é¢‘, url=', msg.url);
        }else if(msg.type==='info'){ log('[INFO]', msg.message||''); }
        else if(msg.type==='error'){ log('âŒ', msg.message||'error'); }
      }catch(e){ /* ignore */ }
    };
  }

  async function start(){
    if(!ws || ws.readyState!==WebSocket.OPEN){ log('è¯·å…ˆè¿æ¥ WS'); return; }
    stream = await navigator.mediaDevices.getUserMedia({audio:true});
    const mime = elSelMime.value;
    rec = new MediaRecorder(stream, {mimeType:mime});
    rec.ondataavailable = async e=>{
      if(e.data && e.data.size>0){
        const buf = await e.data.arrayBuffer();
        if(ws && ws.readyState===WebSocket.OPEN){ ws.send(buf); }
      }
    };
    rec.onstart = ()=> log('[REC] start');
    rec.onstop  = ()=> log('[REC] stop');
    rec.start(parseInt(elChunk.value||'320',10));
  }
  function stop(){
    if(rec && rec.state!=='inactive') rec.stop();
    if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; }
    if(ws && ws.readyState===WebSocket.OPEN){ ws.send(JSON.stringify({type:'stop'})); log('ğŸ“¨ å·²å‘é€ stop æŒ‡ä»¤'); }
  }

  async function mockTTS(){
    const txt = 'æ‚¨å¥½ï¼Œæˆ‘æ˜¯è®¯é£è¯­éŸ³åŠ©æ‰‹ï¼Œæ­£åœ¨ä¸ºæ‚¨æœåŠ¡ã€‚';
    try{
      const r = await fetch('/api/tts?'+new URLSearchParams({text:txt}));
      const j = await r.json();
      if(j.ok){ q.push(j.url); log('âœ… æ¨¡æ‹ŸTTSæˆåŠŸ, size=', j.size); }
      else{ log('âŒ TTSå¤±è´¥:', j.message); }
    }catch(e){ log('âŒ TTSè¯·æ±‚å¼‚å¸¸:', e.message||e); }
  }

  btnInit.addEventListener('click', unlock);
  btnWS.addEventListener('click', connectWS);
  btnStart.addEventListener('click', start);
  btnStop.addEventListener('click', stop);
  btnMock.addEventListener('click', mockTTS);

  ['click','touchstart'].forEach(evt=>document.addEventListener(evt, ()=>{ if(!audioUnlocked) unlock(); }, {once:true}));

  log('å‡†å¤‡å°±ç»ªï¼š1) åˆå§‹åŒ–éŸ³é¢‘ 2) è¿æ¥åç«¯ 3) å¼€å§‹è¯´è¯ â†’ åœæ­¢ã€‚åœæ­¢åæœåŠ¡ç«¯ä¼šè‡ªåŠ¨åˆæˆå¹¶æ’­æŠ¥æ¨¡æ‹Ÿå›ç­”ã€‚');
})();
</script>
</body>
</html>
